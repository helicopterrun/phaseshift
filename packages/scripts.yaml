# scripts.yaml

script:

  #──────────────────────────────────────────────────────────────
  # Publish the correct setpoints for the current mode
  #──────────────────────────────────────────────────────────────
  - id: publish_mode_setpoints
    then:
      - lambda: |-
          std::string m = id(mode).state;
          float db, dp;
          if (m == "Ramp") {
            db = id(ramp_temp_setpoint_dynamic).state;
            dp = id(ramp_dwpt_setpoint_dynamic).state;
          } else if (m == "Plateau") {
            db = id(plateau_temp).state;
            dp = id(plateau_dwpt).state;
          } else {  // Hold
            db = id(hold_temp).state;
            dp = id(hold_dwpt).state;
          }
          id(drybulb_setpoint).publish_state(db);
          id(dewpoint_setpoint).publish_state(dp);
      - script.execute: activate_setpoints

  #──────────────────────────────────────────────────────────────
  # Automatically change mode based on elapsed days
  #──────────────────────────────────────────────────────────────
  - id: update_mode_from_elapsed
    mode: restart
    then:
      - if:
          condition:
            lambda: 'return id(elapsed_days).state < id(ramp_duration).state;'
          then:
            - if:
                condition:
                  lambda: 'return id(mode).state != "Ramp";'
                then:
                  - select.set:
                      id: mode
                      option: "Ramp"
      - if:
          condition:
            lambda: 'return id(elapsed_days).state >= id(ramp_duration).state && id(elapsed_days).state < (id(ramp_duration).state + id(plateau_duration).state);'
          then:
            - if:
                condition:
                  lambda: 'return id(mode).state != "Plateau";'
                then:
                  - select.set:
                      id: mode
                      option: "Plateau"
      - if:
          condition:
            lambda: 'return id(elapsed_days).state >= (id(ramp_duration).state + id(plateau_duration).state);'
          then:
            - if:
                condition:
                  lambda: 'return id(mode).state != "Hold";'
                then:
                  - select.set:
                      id: mode
                      option: "Hold"

  #──────────────────────────────────────────────────────────────
  # Update circulation fan whenever called
  #──────────────────────────────────────────────────────────────
  - id: update_circulation_fan
    mode: restart
    then:
      - component.update: circ_fan_command

  #──────────────────────────────────────────────────────────────
  # TEC driver initialization on boot
  #──────────────────────────────────────────────────────────────
  - id: ti_driver_startup
    then:
      - output.turn_off: nsleep_a
      - output.turn_off: nsleep_b
      - delay: 100ms
      - output.turn_on: p_mode
      - output.set_level:
          id: imode_a
          level: 0%
      - output.set_level:
          id: imode_b
          level: 0%
      - output.turn_on: nsleep_a
      - output.turn_on: nsleep_b
      - number.set:
          id: pwm_max_current_number
          value: ${default_max_current}
      - button.press: apply_current_settings
      - number.set:
          id: tec_pl_number
          value: 0.0
      - button.press: set_pwm

  #──────────────────────────────────────────────────────────────
  # Return to saved defaults on boot
  #──────────────────────────────────────────────────────────────
  - id: return_to_default
    then:
      - script.execute: restore_mode
      - script.execute: init_units
      - script.execute: init_setpoints_from_mode
      - script.execute: update_circulation_fan

  - id: restore_mode
    then:
      - select.set:
          id: mode
          option: !lambda 'return id(last_mode);'

  - id: init_units
    then:
      - if:
          condition:
            lambda: 'return ${use_fahrenheit};'
          then:
            - switch.turn_on: use_fahrenheit
          else:
            - switch.turn_off: use_fahrenheit

  #──────────────────────────────────────────────────────────────
  # Initialize setpoints based on the last mode
  #──────────────────────────────────────────────────────────────
  - id: init_setpoints_from_mode
    then:
      - script.execute: publish_mode_setpoints

  #──────────────────────────────────────────────────────────────
  # Push current setpoints to climate & sensors
  #──────────────────────────────────────────────────────────────
  - id: activate_setpoints
    then:
      - button.press: submit_values

  #──────────────────────────────────────────────────────────────
  # Temporary defrost cycle if icing detected
  #──────────────────────────────────────────────────────────────
  - id: defrost_cycle
    then:
      - logger.log: "Defrost cycle initiated"
      - climate.control:
          id: pid_cold
          mode: HEAT_COOL
          target_temperature: 5°C
      - delay: 5min
      - logger.log: "Resuming normal cooling"
      - climate.control:
          id: pid_cold
          mode: COOL
          target_temperature: !lambda 'return id(cold_hs_setpoint).state;'

  #──────────────────────────────────────────────────────────────
  # Update elapsed‐time sensors
  #──────────────────────────────────────────────────────────────
  - id: update_elapsed_times
    then:
      - component.update: elapsed_days
      - component.update: ramp_days
      - component.update: plateau_days
      - component.update: hold_days

  #──────────────────────────────────────────────────────────────
  # Apply new mode’s setpoints immediately
  #──────────────────────────────────────────────────────────────
  - id: apply_current_mode_setpoints
    mode: restart
    then:
      - script.execute: publish_mode_setpoints
